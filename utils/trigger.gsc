/*// bad design! better in on_player as threadTRIGGER_watch_leave(player){	trigger = self;	while (trigger isTouching(player))		wait 0.05;	trigger [[trigger.methodLeave]](player);}*/TRIGGER_on_player(player){	trigger = self;		/* its kind of OOP-method on trigger */	if (isDefined(trigger.methodTouch))		trigger [[trigger.methodTouch]](player);		while (isDefined(player) && trigger isTouching(player))	{		if (player useButtonPressed())		{			if (isDefined(trigger.methodUse))				trigger [[trigger.methodUse]](player);			while (player useButtonPressed())				wait 0.05;		}		wait 0.05;	}	wait 0.10; /* else it will be touching rapidly again */	if (isDefined(player))		player.isOnTrigger = undefined;	if (isDefined(trigger.methodLeave))		trigger [[trigger.methodLeave]](player);}TRIGGER_add(origin, functionUse, functionTouch, functionLeave, data/*like hintstring*/){	trigger = spawn("trigger_radius", origin, 0, 50, 50);		/* like OOP */	trigger.data = data;	trigger.methodUse = functionUse;	trigger.methodTouch = functionTouch;	trigger.methodLeave = functionLeave;		return trigger;}TRIGGER_new(origin){	trigger = spawn("trigger_radius", origin, 0, 50, 50);	return trigger;}TRIGGER_delete(){	trigger = self;	trigger delete();}TRIGGER_run(){	trigger = self;	while (1)	{		trigger waittill("trigger", player);				if (isDefined(player.isOnTrigger))			continue;		player.isOnTrigger = true;				trigger thread TRIGGER_on_player(player);	}}TRIGGER_run_singlethreaded(){	trigger = self;	while (1)	{		trigger waittill("trigger", player);				trigger TRIGGER_on_player(player);	}}